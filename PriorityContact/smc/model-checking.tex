\section{Model Checking}

Model checking constructs an exhaustive proof to show that a transition system implements a specification. Modeling any system requires the definition of all events in the system; these events are sometimes referred to as \emph{atomic propositions}. A model produces a set of sequences of atomic propositions that represent the behavior of the system. Typically the model is described in some high-level language, and the semantics of that language yields sequences of atomic propositions that represent the language of the model as shown in the Venn diagram in Figure XX.

The specification is also a language over atomic propositions that precisely describes sequences of interest. This language is usually presented in logic \cite{LTL, CTL}, and that logic describes sequences of atomic propositions that represent the correct language for the system. The inversion of this language creates a language of bad sequences that are not allowed by the specification. In the Venn diagram, this is the region labeled \emph{Universe minus Specification}.

Model checking is the process of proving that the intersection of the language defined by the model and the language defined by the inverse of the specification is empty: no words are common to the two languages. If such is not the case, then model checking provides a counter-example: a sequence produced by the model but not allowed by the specification.

The use of CWP for verifying the workflows of interactive HIT systems is straightforward conceptually given the definition of model checking. The atomic propositions are the state labels in the CWP state diagram. For the Priority Contact model, these are: \emph{Launched}, \emph{Conversation in Progress}, \emph{Appointment Scheduled}, \emph{Resolved}, and \emph{No longer needed}. The workflow model evolves the CWP from the initial \emph{Launched} state and thus produces sequences of atomic propositions. These sequences are the language of the model. Any sequence from the initial state produced on any path in the workflow is part of that language.

The specification contains those sequences allowed by the state diagram in the CWP that start in the \emph{Launched} state and end in the \emph{No longer needed} state and only follow transitions defined in the state diagram. Sequences not in the language of the specification represent bad sentences that the model must never produce. For the priority contact example, bad sequences are those that do not end in the \emph{No longer needed} state or those that make illegal transitions such as moving from the \emph{Launched} state directly to the \emph{Resolved} state.

Model checking follows every possible path in the workflow looking for bad sequences. If such a sentence exists, then the language generated by the model is not contained within the language defined by the specification, and the discovered bad sentence is reported as a violation. In general, model checking does not enumerate all bad sequences (if any exist) as only one is required to prove the relationship between the language of the model and the language of the specification. 

The SPIN model checker is used in this work, and the translation of the CWP and Mathflow model to the SPIN input language is described in the next section. The rest of this section is devoted to the results of model checking the Priority Contact example. The SPIN model checker discovered errors in all of the priorities where the workflow did not evolve the CWP to the \emph{No longer needed} state. To bring this result into context, only one of the errors was seeded purposely by the modelers with the modelers believing the model to be correct, except for the seeded error, having carefully reviewed the model on several occasions.

Figure 2 is the top-level description of the different levels of priority in the Priority Contact system. \textbb{NOTE: this figure is not current and needs to be updated.}
\begin{itemize}
\item \emph{P1 Life Threatening}: in the \emph{PC carry out contact plan P1} process a gateway had no outgoing edge and was essentially disconnected from the rest of the model. As a result, any path leading to that gateway left the CWP in an invalid end state. The error was corrected by connecting the gateway to the remaining flows.

\item \emph{P2 Life Changing}: this errors was seeded by the modelers. In the \emph{Doctor inform patient of results} process action to move the CWP into the \emph{No longer needed} state was removed by the modelers.

\item \emph{P3 routine change}: the modelers had included a \emph{Preferred mode of Communication} gateway where the user is able to designate \emph{Mail}, \emph{Auto-call}, or \emph{MyHealthEvet}. In the cases of \emph{Mail} and \emph{MyHeathEvet}, the tasks failed to move the CWP out of the \emph{Launched} state. The error was corrected by removing the gateway as these options were hold-overs from a prior design that the designers had failed to remove.

\item \emph{P4 no change}: aside from the legacy gateway carried over from a prior design that was identical to the \emph{P3 routine change} error, this priority failed to moved the CWP out of the \emph{Launched} state. Neither the \emph{Make phone clinic appointment P4} nor the \emph{Discuss no change} processes recorded the scheduled appointment, conversation, or resolution of the priority contact on any path. The error was corrected by updating the CWP in the associated tasks to mark the appointment, conversation, and have the doctor note the resolution.

The errors, though seemingly trivial, persisted through several reviews of the model, indicating the value of model checking if for nothing more than a more precise sanity check on the connectivity of the model and the basic evolution of the CWP.


\section{Building the Promela Model for SPIN}

Novel in the approach is the direct use of the CWP as the specification for the model checking step using the SPIN model checker 15 The CWP as the specification for model checking is in direct contrast with prior work that would rather restate the CWP as a temporal logic specification. Using the CWP directly as the property to verify in model checking separates the verification process into two steps: first, verify that the CWP describes the intended work; and second, verify that the work-flow accomplishes the intended work. 

The input to the verification process is the MATHflow model of the work-flow with the CWP. The CWP consists of two components: the ontology describing the state of the CWP, and the state chart describing the legal evolution of that state. The MATHflow model with its various attributes presents a well-defined interface to interact with the state of the CWP. In particular, that MATHflow model indicates where and how it changes attributes of the CWP.  The verification process is now readily defined given this property of MATHflow models: 

1. The MATHflow model is analyzed to extract the interaction with the CWP.
2. The CWP ontology is abstracted to the defined interaction in the MATHflow model and expressed as a data structure in SPIN.
3. The MATHflow model is analyzed to extract interaction between actors. 
4. The MATHflow model is translated into Promela, the SPIN modeling language, with each actor interacting with the data-structure and communication channels as appropriate.
5. The CWP state chart is directly expressed as a never claim in Promela.
6. SPIN model checks the never claim looking for violations.

Steps (1) and (2) of the verification process are the most complex. The CWP ontology defines all the information related to the CWP with its intra-relations, but not all that information, nor its intra-relations, indicate the state of the CWP or are directly utilized in the MATHflow model. 

Continuing with the example of the priority contact ontology, the MATHflow model of the priority contact only cares if a lab result indicates that the diagnosis is life threatening, life changing, routine, or no change relative to the patient's life. As such, the data structure representing the ontology in the Promela verification model can safely abstract anything related to the disease, including the symptoms and treatment plan, to just a single field to indicate one of the four previously mentioned categories: life threatening, life changing, routine, or no change.  As a further example, although the CWP ontology includes all the information necessary to contact the patient, the actual name of the patient or contact information, that information only read in the MATHflow process, and it is not later updated or used in making a decision, so it is omitted from the data structure representing the CWP ontology. In this way, steps (1) and (2) abstract the CWP ontology to two parts: fields that are written by the MATHflow model and fields that are used by the MATHflow model to make decisions (e.g., a life threatening lab result follows a different process than a routine lab result). The process of creating the ontology abstraction from the MATHflow model is difficult to automate and expected to be a manual exercise for the modeler.

Step (3) relates to the different actors in the MATHflow model. Each of these actors is a process in SPIN, and as processes, operate concurrently. For example, in a life threatening diagnosis, an attempt to contact the patient via phone is made, and if that fails, the patient is sent texts and voice mails, as are the emergency contacts, until the patient is found. This synchronization is modeled either with a communication channel in Promela, or a shared variable that is accessed by the parties involved in the communication. The choice of communication is still an active area of research in the model generation, but the important aspect is that the communication can either be asynchronous (e.g., a text is sent to the patients phone) or synchronous (e.g., the patient answers the phone). In either case, the communication is identified and defined in step (3).

Step (4) can be readily mechanized since the translation from MATHflow to Promela is nearly one-to-one. Each actor is modeled with a process in Promela, and that process is defined as a state machine. The state machine description has a label marking the state, a step of actions that take place in that state, and goto statements moving to the next state in the MATHflow model as appropriate. The actions either read input from the CWP ontology data-structure (e.g., is this life-threatening, etc.), update the state of the ontology (e.g., set the priority to high or mark the contact as launched), or communicate with another actor. Step (4) is somewhat trivial by virtue of steps (1) through (3) which do all the heavy lifting in the abstraction of the ontology and the definition of the communication.

As a matter of completeness, the MATHflow model does include non-determinism. Such non-determnism in the Priority Contact model takes place in the severity of the diagnosis to and whether or not a patient is able to answer the phone immediately. This non-determinism is included in the Promela model, and SPIN explores all possible ways to resolve the non-determinism. As a reminder though, the actors always behave in a nominal way. For example, if the patient receives a text, then the patient follows the instructions in the text.


\section{Related Work}

Model checking proves a transition system implements a
specification. To date, much of the research with model checking in
health care has focused on formalizing work flows and proving temporal
properties on work flows \cite{avrunin, clark, baski} or on developing new modeling
languages to describe work-flows and human machine teaming in those
work-flows \cite{mathflow, boulton}. The approach in this paper shifts
focus to the work intended to be accomplished by a work-flow. It uses
model checking to prove that a work-flow accomplishes the work
declared in the CWP. Also, unlike prior work, this approach to model checking tries to use the CWP state diagram directly to prove the correctness of the system. This approach is in direct contrast to \cite{avrunin, clark, baski} where the system specification is expressed in terms of formal logic.
